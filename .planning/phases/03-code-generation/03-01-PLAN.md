---
phase: 03-code-generation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bitschema/codegen.py
  - tests/test_codegen.py
  - bitschema/__init__.py
autonomous: true

must_haves:
  truths:
    - "Generated dataclass has correctly typed fields matching schema"
    - "Generated encode() method produces same output as runtime encoder"
    - "Generated decode() classmethod produces same output as runtime decoder"
    - "Generated code is syntactically valid Python"
    - "Generated code includes helpful docstrings"
  artifacts:
    - path: "bitschema/codegen.py"
      provides: "Dataclass code generation from schema and layouts"
      exports: ["generate_dataclass_code"]
      min_lines: 100
    - path: "tests/test_codegen.py"
      provides: "Code generation tests"
      exports: []
      min_lines: 150
  key_links:
    - from: "bitschema/codegen.py"
      to: "bitschema/encoder.py"
      via: "uses normalize_value logic in generated encode method"
      pattern: "normalize_value"
    - from: "bitschema/codegen.py"
      to: "bitschema/decoder.py"
      via: "uses denormalize_value logic in generated decode method"
      pattern: "denormalize_value"
    - from: "tests/test_codegen.py"
      to: "ast.parse"
      via: "validates generated code is syntactically correct"
      pattern: "ast\\.parse"
---

<objective>
Generate static Python dataclass code from BitSchema schemas with type-safe encode/decode methods

Purpose: Enables zero-runtime-overhead encoding/decoding with full IDE support and type checking. Generated code eliminates schema parsing overhead and provides compile-time type safety.

Output: Working dataclass code generator producing formatted, type-hinted Python code with encode/decode methods that match runtime encoder/decoder behavior exactly.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-generation/03-RESEARCH.md

# Existing runtime components (for reference - not modification)
@bitschema/encoder.py
@bitschema/decoder.py
@bitschema/models.py
@bitschema/layout.py
</context>

<feature>
  <name>Dataclass Code Generator</name>
  <files>
    bitschema/codegen.py
    tests/test_codegen.py
  </files>
  <behavior>
    Generate Python dataclass code from BitSchema and FieldLayout list.

    Input: BitSchema, list[FieldLayout]
    Output: Python code string with:
      - @dataclass class with correctly typed fields
      - Type hints using Python 3.10+ syntax (int | None for nullable)
      - encode() method returning int (uses LSB-first accumulator pattern from encoder.py)
      - decode() classmethod accepting int and returning dataclass instance (uses bit extraction from decoder.py)
      - Comprehensive docstrings with field constraints and bit positions
      - Formatted code (try Ruff, graceful fallback to unformatted)

    Test cases:
      - Boolean field → generates "field_name: bool"
      - Integer field → generates "field_name: int" with min/max in docstring
      - Enum field → generates "field_name: str" (or Literal["v1", "v2"])
      - Nullable field → generates "field_name: int | None = None"
      - encode() method → generates bit-packing logic matching encoder.py
      - decode() method → generates bit-extraction logic matching decoder.py
      - Multi-field schema → generates all fields in declaration order
      - Generated code is syntactically valid (ast.parse succeeds)
      - Generated encode/decode produce identical results to runtime (round-trip test)
  </behavior>
  <implementation>
    Use f-strings with textwrap.dedent() and textwrap.indent() for code generation.

    Structure:
    1. generate_field_type_hint(field_def) → str
       - Maps BoolFieldDefinition → "bool"
       - Maps IntFieldDefinition → "int"
       - Maps EnumFieldDefinition → "str" (or Literal if all enum values are known)
       - Adds "| None" suffix for nullable fields

    2. generate_field_definitions(schema) → str
       - Iterate schema.fields in order
       - Generate "name: type_hint" or "name: type_hint = None" for nullable
       - Indent with textwrap.indent("    ")

    3. generate_encode_method(schema, layouts) → str
       - Implement LSB-first accumulator pattern from encoder.py
       - For each field: normalize, mask, shift, OR into accumulator
       - Handle nullable presence bits
       - Include inline comments with bit positions

    4. generate_decode_method(schema, layouts) → str
       - Extract bits at each field's offset using (encoded >> offset) & mask
       - Denormalize values (add min for integers, index enum values)
       - Handle nullable presence bits
       - Return cls(...) with all field values

    5. generate_dataclass_code(schema, layouts) → str
       - Combine all parts with proper indentation
       - Add module docstring
       - Add class docstring with field list and bit count
       - Import dataclasses and type hints
       - Format with format_generated_code() (optional Ruff)

    6. format_generated_code(code: str) → str
       - Try subprocess.run(["ruff", "format", "-"], ...)
       - Catch subprocess.CalledProcessError or FileNotFoundError
       - Return original code if formatter unavailable

    7. validate_generated_code(code: str) → bool
       - ast.parse(code) to verify syntax
       - Return True if valid, raise SyntaxError otherwise

    RED phase tests:
    - test_generate_boolean_field_type_hint
    - test_generate_integer_field_type_hint
    - test_generate_nullable_field_type_hint
    - test_generate_single_field_dataclass
    - test_generate_multi_field_dataclass
    - test_generated_code_is_valid_python
    - test_generated_encode_matches_runtime
    - test_generated_decode_matches_runtime
    - test_round_trip_with_generated_code

    GREEN phase implementation:
    - Implement all generator functions
    - Use existing encoder/decoder logic patterns
    - Format with Ruff if available
    - Validate with ast.parse
  </implementation>
</feature>

<verification>
Run test suite:
```bash
pytest tests/test_codegen.py -v
```

Should see:
- All type hint generation tests pass
- All field definition generation tests pass
- All encode/decode generation tests pass
- Generated code validation passes (ast.parse succeeds)
- Round-trip correctness test passes (generated code produces same results as runtime)
</verification>

<success_criteria>
1. generate_dataclass_code() produces syntactically valid Python code
2. Generated dataclass has correct type hints for all field types (bool, int, str, nullable)
3. Generated encode() method produces identical output to runtime encoder for same input
4. Generated decode() classmethod produces identical output to runtime decoder for same input
5. Generated code includes docstrings with field constraints and total bit count
6. Code is formatted (Ruff) or readable (if formatter unavailable)
7. All tests pass (10+ test cases covering all field types and edge cases)
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-generation/03-01-SUMMARY.md`

Follow TDD workflow:
- RED phase: Write failing tests, commit with "test(03-01): ..."
- GREEN phase: Implement to pass tests, commit with "feat(03-01): ..."
- REFACTOR phase (if needed): Clean up code, commit with "refactor(03-01): ..."
</output>
