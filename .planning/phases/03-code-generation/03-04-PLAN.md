---
phase: 03-code-generation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bitschema/__main__.py
  - pyproject.toml
  - tests/test_cli.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Developer can run CLI command to generate Python dataclass from schema"
    - "CLI accepts schema file path and optional output file path"
    - "CLI provides helpful error messages for invalid inputs"
  artifacts:
    - path: "bitschema/__main__.py"
      provides: "CLI entry point with argparse command parser"
      min_lines: 80
      exports: ["main"]
    - path: "pyproject.toml"
      provides: "[project.scripts] entry point"
      contains: "bitschema ="
    - path: "tests/test_cli.py"
      provides: "CLI integration tests"
      min_lines: 100
  key_links:
    - from: "bitschema/__main__.py"
      to: "bitschema.codegen.generate_dataclass_code"
      via: "import and invoke"
      pattern: "from bitschema import.*generate_dataclass_code"
    - from: "bitschema/__main__.py"
      to: "bitschema.parser.parse_schema_file"
      via: "import and invoke"
      pattern: "from bitschema import.*parse_schema_file"
    - from: "pyproject.toml"
      to: "bitschema.__main__:main"
      via: "[project.scripts] console_scripts"
      pattern: "bitschema.*=.*bitschema\\.__main__:main"
---

<objective>
Add CLI wrapper to invoke existing code generation, JSON Schema export, and visualization functionality from command line.

Purpose: Close verification gap by providing command-line interface as specified in Phase 3 success criterion #1
Output: Working CLI accessible as `bitschema` command with subcommands for generate, jsonschema, and visualize
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-generation/03-VERIFICATION.md
@.planning/phases/03-code-generation/03-01-SUMMARY.md
@.planning/phases/03-code-generation/03-02-SUMMARY.md
@.planning/phases/03-code-generation/03-03-SUMMARY.md
@bitschema/__init__.py
@bitschema/codegen.py
@bitschema/jsonschema.py
@bitschema/visualization.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI entry point with argparse subcommands</name>
  <files>bitschema/__main__.py</files>
  <action>
Create bitschema/__main__.py with argparse-based CLI supporting three subcommands:

1. **generate** subcommand (dataclass code generation):
   - Required: schema_file (path to JSON/YAML schema)
   - Optional: --output OUTPUT_FILE (default: stdout)
   - Optional: --class-name NAME (default: derived from schema file stem)
   - Implementation: parse_schema_file() → compute_bit_layout() → generate_dataclass_code() → write to file or stdout

2. **jsonschema** subcommand (JSON Schema export):
   - Required: schema_file (path to JSON/YAML schema)
   - Optional: --output OUTPUT_FILE (default: stdout)
   - Optional: --indent SPACES (default: 2)
   - Implementation: parse_schema_file() → compute_bit_layout() → generate_json_schema() → json.dumps() → write to file or stdout

3. **visualize** subcommand (bit layout visualization):
   - Required: schema_file (path to JSON/YAML schema)
   - Optional: --format {ascii,markdown} (default: ascii)
   - Optional: --output OUTPUT_FILE (default: stdout)
   - Implementation: parse_schema_file() → compute_bit_layout() → visualize_bit_layout_ascii() or visualize_bit_layout_markdown() → write to file or stdout

**Error handling:**
- FileNotFoundError: "Error: Schema file not found: {path}"
- ValidationError/SchemaError: "Error: Invalid schema: {error.message}"
- EncodingError: Should not occur in CLI (pre-generation validation only)
- Catch all exceptions and exit with code 1

**Imports:**
- Use existing public API from bitschema/__init__.py
- Import argparse (stdlib), sys (stdlib), json (stdlib for jsonschema indent)
- Use Path from pathlib for file operations

**Structure:**
```python
def main():
    parser = argparse.ArgumentParser(...)
    subparsers = parser.add_subparsers(...)

    # generate subcommand
    generate_parser = subparsers.add_parser('generate', ...)
    generate_parser.add_argument('schema_file', ...)
    generate_parser.add_argument('--output', ...)
    generate_parser.set_defaults(func=cmd_generate)

    # jsonschema subcommand
    # visualize subcommand

    args = parser.parse_args()
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()

def cmd_generate(args): ...
def cmd_jsonschema(args): ...
def cmd_visualize(args): ...

if __name__ == '__main__':
    main()
```

**Why argparse:** Stdlib, zero dependencies, standard Python CLI pattern. Avoid click/typer to minimize dependencies (project currently has only pydantic, PyYAML, tabulate).
  </action>
  <verify>
Run manual CLI tests:
```bash
# Test generate to stdout
python -m bitschema generate tests/fixtures/person.yaml

# Test generate to file
python -m bitschema generate tests/fixtures/person.yaml --output /tmp/person.py
cat /tmp/person.py

# Test jsonschema
python -m bitschema jsonschema tests/fixtures/person.yaml

# Test visualize ascii
python -m bitschema visualize tests/fixtures/person.yaml

# Test visualize markdown
python -m bitschema visualize tests/fixtures/person.yaml --format markdown

# Test error handling
python -m bitschema generate nonexistent.yaml  # Should show clear error
python -m bitschema  # Should show help
```
  </verify>
  <done>
bitschema/__main__.py exists with main() function, three subcommands (generate, jsonschema, visualize), proper error handling with sys.exit(1), and manual tests pass with expected output to stdout/files
  </done>
</task>

<task type="auto">
  <name>Task 2: Add console_scripts entry point to pyproject.toml</name>
  <files>pyproject.toml</files>
  <action>
Add [project.scripts] section to pyproject.toml to register `bitschema` command:

```toml
[project.scripts]
bitschema = "bitschema.__main__:main"
```

This enables `bitschema` as a command after `pip install -e .` or package installation.

Place this section after [project.optional-dependencies] and before [tool.setuptools.packages.find].
  </action>
  <verify>
Install package in editable mode and test CLI:
```bash
pip install -e .
which bitschema  # Should show installed command
bitschema --help  # Should show argparse help
bitschema generate tests/fixtures/person.yaml --output /tmp/person_cli.py
cat /tmp/person_cli.py  # Should contain dataclass code
```
  </verify>
  <done>
pyproject.toml contains [project.scripts] section with bitschema entry point, `pip install -e .` succeeds, `bitschema` command is available in PATH, and `bitschema generate` produces expected output
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CLI integration tests (TDD approach)</name>
  <files>tests/test_cli.py</files>
  <action>
Create tests/test_cli.py with comprehensive CLI integration tests using subprocess to invoke CLI:

**Test structure:**
```python
import subprocess
import json
import pytest
from pathlib import Path

def run_cli(*args):
    """Helper to run bitschema CLI and capture output."""
    result = subprocess.run(
        ["python", "-m", "bitschema", *args],
        capture_output=True,
        text=True,
    )
    return result

class TestGenerateCommand:
    def test_generate_to_stdout(self):
        # Run: python -m bitschema generate tests/fixtures/person.yaml
        # Assert: returncode 0, stdout contains "class", "def encode", "def decode"

    def test_generate_to_file(self, tmp_path):
        # Run: --output tmp_path/out.py
        # Assert: file exists, contains valid Python (ast.parse), has expected class

    def test_generate_with_custom_class_name(self, tmp_path):
        # Run: --class-name CustomPerson
        # Assert: output contains "class CustomPerson"

    def test_generate_nonexistent_file(self):
        # Run: nonexistent.yaml
        # Assert: returncode 1, stderr contains "not found"

class TestJsonSchemaCommand:
    def test_jsonschema_to_stdout(self):
        # Run: python -m bitschema jsonschema tests/fixtures/person.yaml
        # Assert: returncode 0, stdout is valid JSON, contains "$schema"

    def test_jsonschema_with_indent(self):
        # Run: --indent 4
        # Assert: JSON formatted with 4-space indent

    def test_jsonschema_to_file(self, tmp_path):
        # Run: --output tmp_path/schema.json
        # Assert: file exists, valid JSON Schema Draft 2020-12

class TestVisualizeCommand:
    def test_visualize_ascii_default(self):
        # Run: python -m bitschema visualize tests/fixtures/person.yaml
        # Assert: returncode 0, stdout contains table with "Field", "Type", "Bits"

    def test_visualize_markdown(self):
        # Run: --format markdown
        # Assert: stdout contains markdown table (starts with "|")

    def test_visualize_to_file(self, tmp_path):
        # Run: --output tmp_path/layout.txt
        # Assert: file exists, contains bit layout table

class TestCLIErrors:
    def test_no_subcommand_shows_help(self):
        # Run: bitschema (no args)
        # Assert: returncode 0 or shows help, stdout contains "usage"

    def test_invalid_schema_shows_error(self):
        # Create fixture with invalid schema (total bits > 64)
        # Assert: returncode 1, stderr contains "Invalid schema" or similar
```

**Key test patterns:**
- Use subprocess.run with capture_output=True to test actual CLI invocation
- Use tmp_path fixture for file output tests
- Test both stdout and file output modes
- Test error conditions (missing files, invalid schemas)
- Verify output format (valid Python, valid JSON, table structure)

**Fixtures:**
- Use existing tests/fixtures/person.yaml for valid schema tests
- Create invalid schema fixture in test itself (inline dict → temp file)
  </action>
  <verify>
Run pytest on CLI tests:
```bash
pytest tests/test_cli.py -v
# All tests should pass
# Coverage should include all three subcommands and error paths
```
  </verify>
  <done>
tests/test_cli.py exists with comprehensive tests for all three subcommands (generate, jsonschema, visualize), tests pass, error handling is verified, and both stdout and file output modes are tested
  </done>
</task>

</tasks>

<verification>
**Manual verification:**

1. Install package and test CLI commands:
```bash
pip install -e .
bitschema --help
bitschema generate tests/fixtures/person.yaml
bitschema jsonschema tests/fixtures/person.yaml
bitschema visualize tests/fixtures/person.yaml --format markdown
```

2. Test error handling:
```bash
bitschema generate nonexistent.yaml  # Clear error message
bitschema  # Shows help
```

3. Test file output:
```bash
bitschema generate tests/fixtures/person.yaml --output /tmp/person.py
python /tmp/person.py  # Should not error (imports work)
```

**Automated verification:**
```bash
pytest tests/test_cli.py -v  # All tests pass
```

**Gap closure verification:**
The verification gap states: "Developer can run CLI command to generate Python dataclass from schema"

Success criteria:
- ✓ CLI command exists: `bitschema generate schema.yaml`
- ✓ Outputs to file or stdout: `--output person.py`
- ✓ Installed as console script: `pip install -e .` then `bitschema`
- ✓ Works as module: `python -m bitschema`
- ✓ Clear error messages on invalid input
</verification>

<success_criteria>
1. Developer can run `bitschema generate schema.yaml` to generate dataclass code
2. Developer can run `bitschema jsonschema schema.yaml` to export JSON Schema
3. Developer can run `bitschema visualize schema.yaml` to view bit layout
4. CLI is installed via `pip install -e .` as `bitschema` command
5. CLI provides helpful error messages for missing files or invalid schemas
6. All CLI tests pass (generate, jsonschema, visualize, error handling)
7. Phase 3 verification truth #1 is satisfied: "Developer can run CLI command to generate Python dataclass from schema"
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-generation/03-04-SUMMARY.md` following the standard summary template with:
- Frontmatter: phase, plan, subsystem (cli), tags, dependencies, tech stack, key files, decisions
- What was built: CLI entry point with argparse, three subcommands, console_scripts registration
- Performance metrics: duration, test count, lines of code
- Key decisions: argparse over click/typer (zero new dependencies), subcommand structure
- Integration points: Wired to codegen.py, jsonschema.py, visualization.py
</output>
