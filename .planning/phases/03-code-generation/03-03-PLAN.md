---
phase: 03-code-generation
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - bitschema/visualization.py
  - tests/test_visualization.py
  - bitschema/__init__.py
autonomous: true

must_haves:
  truths:
    - "Bit layout table shows field name, type, bit range, bit count, and constraints"
    - "Bit ranges are accurate (offset:offset+bits-1 format)"
    - "ASCII table format is readable with borders and alignment"
    - "Markdown table format is valid GitHub-flavored markdown"
    - "Constraints display is human-friendly (e.g., '[0..100]' for integers)"
  artifacts:
    - path: "bitschema/visualization.py"
      provides: "Bit layout visualization tables"
      exports: ["visualize_bit_layout", "visualize_bit_layout_ascii", "visualize_bit_layout_markdown"]
      min_lines: 60
    - path: "tests/test_visualization.py"
      provides: "Visualization tests"
      exports: []
      min_lines: 80
  key_links:
    - from: "bitschema/visualization.py"
      to: "tabulate library"
      via: "uses tabulate for table generation"
      pattern: "from tabulate import tabulate"
    - from: "bitschema/visualization.py"
      to: "bitschema/layout.py"
      via: "reads FieldLayout for bit positions and constraints"
      pattern: "FieldLayout"
---

<objective>
Generate human-readable bit layout visualizations showing field positions and constraints

Purpose: Helps developers understand bit packing structure, debug layout issues, and document schemas. Provides both ASCII tables (for console/logs) and markdown tables (for documentation).

Output: Visualization functions producing formatted tables with field details, bit ranges, and constraints in both ASCII grid and markdown formats.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-code-generation/03-RESEARCH.md

# Existing components
@bitschema/layout.py
</context>

<feature>
  <name>Bit Layout Visualization</name>
  <files>
    bitschema/visualization.py
    tests/test_visualization.py
  </files>
  <behavior>
    Generate ASCII and markdown tables showing bit layout details.

    Input: list[FieldLayout]
    Output: Formatted table string with columns:
      - Field: field name
      - Type: bool, int, enum
      - Bit Range: "offset:offset+bits-1" (e.g., "0:7" for 8 bits starting at 0)
      - Bits: total bit count
      - Constraints: human-friendly constraint display

    Constraint display format:
      - Boolean: "-" (no constraints)
      - Integer: "[min..max]" (e.g., "[0..100]")
      - Enum: "N values" (e.g., "3 values")
      - Nullable: add "(nullable)" suffix

    Example output (ASCII grid):
    ```
    +------------+------+-----------+------+--------------+
    | Field      | Type | Bit Range | Bits | Constraints  |
    +============+======+===========+======+==============+
    | active     | bool | 0:0       | 1    | -            |
    | priority   | int  | 1:3       | 3    | [0..7]       |
    | status     | enum | 4:5       | 2    | 3 values     |
    +------------+------+-----------+------+--------------+
    ```

    Example output (Markdown):
    ```
    | Field    | Type | Bit Range | Bits | Constraints |
    |----------|------|-----------|------|-------------|
    | active   | bool | 0:0       | 1    | -           |
    | priority | int  | 1:3       | 3    | [0..7]      |
    | status   | enum | 4:5       | 2    | 3 values    |
    ```

    Test cases:
      - Boolean field → "0:0", 1 bit, "-" constraints
      - Integer field → correct bit range, "[min..max]" constraints
      - Enum field → correct bit range, "N values" constraints
      - Nullable field → "(nullable)" in constraints
      - Multi-field layout → all fields in order
      - ASCII format → has borders and alignment
      - Markdown format → valid markdown table
  </behavior>
  <implementation>
    Use tabulate library for table generation.

    Structure:
    1. format_bit_range(layout: FieldLayout) → str
       - Calculate end bit: offset + bits - 1
       - Return f"{offset}:{end}"

    2. format_constraints(layout: FieldLayout) → str
       - Check layout.type
       - Boolean: return "-"
       - Integer: return f"[{constraints['min']}..{constraints['max']}]"
       - Enum: return f"{len(constraints['values'])} values"
       - Add " (nullable)" suffix if layout.nullable

    3. visualize_bit_layout_ascii(layouts: list[FieldLayout]) → str
       - Build table_data list of [name, type, bit_range, bits, constraints]
       - Use tabulate(table_data, headers=headers, tablefmt="grid")
       - Return ASCII table string

    4. visualize_bit_layout_markdown(layouts: list[FieldLayout]) → str
       - Build table_data same as ASCII
       - Use tabulate(table_data, headers=headers, tablefmt="github")
       - Return markdown table string

    5. visualize_bit_layout(layouts: list[FieldLayout], format: str = "ascii") → str
       - Dispatch to ASCII or markdown based on format parameter
       - Support format="ascii" or format="markdown"
       - Raise ValueError for unknown formats

    Dependencies:
    - Add tabulate to dependencies in pyproject.toml
    - pip install tabulate

    RED phase tests:
    - test_format_bit_range_single_bit
    - test_format_bit_range_multiple_bits
    - test_format_constraints_boolean
    - test_format_constraints_integer
    - test_format_constraints_enum
    - test_format_constraints_nullable
    - test_visualize_ascii_format
    - test_visualize_markdown_format
    - test_multi_field_layout

    GREEN phase implementation:
    - Implement formatting functions
    - Use tabulate for both formats
    - Handle all field types
    - Add nullable suffix
  </implementation>
</feature>

<verification>
Run test suite:
```bash
pytest tests/test_visualization.py -v
```

Should see:
- All bit range formatting tests pass
- All constraint formatting tests pass
- ASCII table generation tests pass (contains borders)
- Markdown table generation tests pass (valid markdown)
- Multi-field layout test passes
</verification>

<success_criteria>
1. format_bit_range() calculates correct bit ranges (offset:end)
2. format_constraints() produces human-friendly constraint strings
3. visualize_bit_layout_ascii() generates ASCII grid table with borders
4. visualize_bit_layout_markdown() generates valid markdown table
5. Nullable fields show "(nullable)" in constraints column
6. All field types display correctly (boolean, integer, enum)
7. Multi-field layouts show all fields in declaration order
8. All tests pass (9+ test cases covering all formatting scenarios)
</success_criteria>

<output>
After completion, create `.planning/phases/03-code-generation/03-03-SUMMARY.md`

Follow TDD workflow:
- RED phase: Write failing tests, commit with "test(03-03): ..."
- GREEN phase: Implement to pass tests, commit with "feat(03-03): ..."
- REFACTOR phase (if needed): Clean up code, commit with "refactor(03-03): ..."
</output>
