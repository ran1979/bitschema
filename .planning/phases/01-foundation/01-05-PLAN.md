---
phase: 01-foundation
plan: 05
type: tdd
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - bitschema/output.py
  - bitschema/__init__.py
  - tests/test_output.py
  - tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "System generates JSON schema with version, total_bits, and field metadata"
    - "Output schema includes per-field: name, type, offset, bits, constraints"
    - "Developer can use complete pipeline: load file → compute layout → generate output"
  artifacts:
    - path: "bitschema/output.py"
      provides: "JSON schema output generation"
      exports: ["generate_output_schema"]
      min_lines: 25
    - path: "bitschema/__init__.py"
      provides: "Public API exports"
      exports: ["BitSchema", "parse_schema_file", "compute_bit_layout", "generate_output_schema"]
      contains: "__all__"
    - path: "tests/test_output.py"
      provides: "Output schema generation tests"
      contains: "test_.*version.*total_bits"
      min_lines: 30
    - path: "tests/test_integration.py"
      provides: "End-to-end integration tests"
      contains: "test_.*json.*to.*layout"
      min_lines: 40
  key_links:
    - from: "bitschema/output.py"
      to: "FieldLayout"
      via: "layout list iteration"
      pattern: "for.*layout.*in.*layouts"
    - from: "bitschema/__init__.py"
      to: "all modules"
      via: "public API exports"
      pattern: "__all__.*=.*\\["
---

<objective>
Implement JSON schema output generation and complete end-to-end integration.

Purpose: Generate compiled schema output in JSON format with all bit layout metadata, and expose complete public API for the foundation phase. Includes integration tests verifying full pipeline works.

Output: Output generator with comprehensive tests plus integration tests validating complete workflow from file to JSON output.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/PROJECT.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/REQUIREMENTS.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-RESEARCH.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-02-PLAN.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-03-PLAN.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-04-PLAN.md
</context>

<feature>
  <name>Schema Output Generation and Integration</name>
  <files>bitschema/output.py, bitschema/__init__.py, tests/test_output.py, tests/test_integration.py</files>
  <behavior>
TDD for schema output generation covering requirements OUTPUT-01, OUTPUT-02, OUTPUT-03, and end-to-end integration.

**Test cases for output generation (RED phase):**

1. **JSON schema structure (OUTPUT-01, OUTPUT-02, OUTPUT-03)**
   - Input: BitSchema with 3 fields + computed layouts
   - Output: dict with keys: version, total_bits, fields
   - version matches input schema version
   - total_bits equals sum of field bits
   - fields is list with length matching input

2. **Per-field metadata (OUTPUT-02)**
   - Each field dict has: name, type, offset, bits, constraints
   - Boolean field: constraints is empty dict
   - Integer field: constraints has min, max
   - Enum field: constraints has values list
   - Offset and bits match FieldLayout values

3. **JSON serializability**
   - Output can be serialized with json.dumps() without errors
   - Serialized JSON can be loaded back with json.loads()

**Test cases for integration (RED phase):**

1. **End-to-end pipeline**
   - Load JSON schema file → parse_schema_file → BitSchema
   - BitSchema → compute_bit_layout → (layouts, total_bits)
   - (BitSchema, layouts, total_bits) → generate_output_schema → JSON dict
   - Verify: input field names match output field names
   - Verify: total_bits in output matches computed total

2. **YAML to output**
   - Same pipeline starting with YAML file
   - Output should be identical to JSON version (same schema content)

3. **64-bit boundary case**
   - Schema with exactly 64 bits → output includes total_bits: 64
   - Schema with 65 bits → compute_bit_layout raises SchemaError (before output)

4. **Public API**
   - All components importable from bitschema package root
   - `from bitschema import BitSchema, parse_schema_file, compute_bit_layout, generate_output_schema`

**Expected behavior:**
- `generate_output_schema(schema: BitSchema, layouts: list[FieldLayout], total_bits: int) -> dict`
- Returns dict matching OUTPUT-01, OUTPUT-02, OUTPUT-03 requirements
- Output is JSON-serializable (no custom types)
- Integration: file → parsed schema → layouts → output schema (full pipeline works)

  </behavior>
  <implementation>
**RED - Write failing tests:**

Create `tests/test_output.py`:
- Import pytest, bitschema modules
- Create mock BitSchema and FieldLayout objects for testing
- Test functions:
  - `test_output_schema_structure` - verify keys: version, total_bits, fields
  - `test_output_field_metadata` - verify each field has name, type, offset, bits, constraints
  - `test_output_boolean_constraints` - boolean field has empty constraints
  - `test_output_integer_constraints` - integer field has min/max constraints
  - `test_output_enum_constraints` - enum field has values list
  - `test_output_json_serializable` - json.dumps(output) works
- Run `pytest tests/test_output.py` - ALL tests must fail
- Commit: `test(01-05): add failing tests for output schema generation`

Create `tests/test_integration.py`:
- Import all bitschema components, pytest, Path
- Test functions:
  - `test_json_file_to_output_schema` - full pipeline with JSON file
  - `test_yaml_file_to_output_schema` - full pipeline with YAML file
  - `test_pipeline_field_names_preserved` - input names match output names
  - `test_pipeline_total_bits_correct` - computed total matches output
  - `test_public_api_imports` - verify __all__ exports
  - `test_64_bit_exact_boundary` - schema with 64 bits succeeds
- Use existing test fixtures from Plan 04
- Run `pytest tests/test_integration.py` - ALL tests must fail
- Commit: `test(01-05): add failing integration tests for complete pipeline`

**GREEN - Implement to pass:**

Create `bitschema/output.py`:
- Import: `from .schema import BitSchema; from .layout import FieldLayout`
- Define `def generate_output_schema(schema: BitSchema, layouts: list[FieldLayout], total_bits: int) -> dict:`
  - Build dict with version, total_bits, fields
  - For each layout in layouts:
    - Create field dict with: name, type, offset, bits, constraints
    - constraints = layout.constraints (already a dict from compute_bit_layout)
  - Return complete dict
- Add docstring explaining output format (matches OUTPUT-01, OUTPUT-02, OUTPUT-03)

Update `bitschema/__init__.py`:
- Import public API components:
  - `from .schema import BitSchema`
  - `from .types import BooleanField, IntegerField, EnumField`
  - `from .parser import parse_schema_file`
  - `from .layout import compute_bit_layout, FieldLayout`
  - `from .output import generate_output_schema`
  - `from .errors import ValidationError, SchemaError`
- Define `__all__` list with all exported names
- Add module docstring: "BitSchema - Deterministic bit-level data packing library"
- Add `__version__ = "0.1.0"`

Run `pytest tests/test_output.py tests/test_integration.py` - ALL tests must pass
Commit: `feat(01-05): implement output schema generation and complete public API`

**REFACTOR (if needed):**
- Add type hints to generate_output_schema
- Improve docstrings with examples showing output format
- Extract constraint formatting if complex
- Ensure JSON output is readable (consider pretty-printing in future CLI)
- Run all tests (entire test suite) - must pass
- Commit if changes made: `refactor(01-05): improve output schema documentation`

  </implementation>
</feature>

<verification>
After TDD cycle completion:

1. `pytest tests/test_output.py tests/test_integration.py -v` - All tests pass
2. Run complete test suite: `pytest -v` - All Phase 1 tests pass
3. Integration test: Create schema file, run full pipeline:
   ```python
   from bitschema import parse_schema_file, compute_bit_layout, generate_output_schema
   from pathlib import Path
   schema = parse_schema_file(Path('tests/fixtures/valid_schema.json'))
   layouts, total = compute_bit_layout(schema.fields)
   output = generate_output_schema(schema, layouts, total)
   print(output['total_bits'])  # Should print total bit count
   ```
4. Verify public API: `python -c "from bitschema import BitSchema, parse_schema_file, compute_bit_layout, generate_output_schema; print('API OK')"` - No import errors
5. Output handles OUTPUT-01, OUTPUT-02, OUTPUT-03 requirements
</verification>

<success_criteria>
- generate_output_schema function exists and returns dict
- Output dict has version, total_bits, fields keys (OUTPUT-01, OUTPUT-03)
- Each field in output has name, type, offset, bits, constraints (OUTPUT-02)
- Output is JSON-serializable (no custom types)
- Integration tests verify complete pipeline: file → schema → layout → output
- Public API defined in __init__.py with __all__ exports
- All major components importable from bitschema package root
- All tests pass (test_output.py, test_integration.py, full suite)
- TDD cycle complete: RED → GREEN → (REFACTOR if needed)
- 3-4 commits created following TDD pattern
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
