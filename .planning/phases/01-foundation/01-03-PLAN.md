---
phase: 01-foundation
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - bitschema/layout.py
  - tests/test_layout.py
autonomous: true

must_haves:
  truths:
    - "System computes deterministic bit offsets for all fields in declared order"
    - "System calculates minimum required bits per field type correctly"
    - "System rejects schemas exceeding 64-bit limit with clear breakdown"
  artifacts:
    - path: "bitschema/layout.py"
      provides: "Bit layout computation logic"
      exports: ["compute_bit_layout", "FieldLayout"]
      contains: "def compute_bit_layout"
      min_lines: 60
    - path: "tests/test_layout.py"
      provides: "Bit layout computation tests"
      contains: "test_.*64.*bit.*limit"
      min_lines: 80
  key_links:
    - from: "bitschema/layout.py"
      to: "int.bit_length()"
      via: "built-in method call"
      pattern: "\\.bit_length\\(\\)"
    - from: "bitschema/layout.py"
      to: "bitschema.errors.SchemaError"
      via: "raise on overflow"
      pattern: "raise SchemaError"
---

<objective>
Implement bit layout computation with deterministic offset assignment and 64-bit validation.

Purpose: Calculate minimum required bits per field and assign sequential offsets, ensuring total bit count stays within 64-bit limit. This is the core mathematical correctness guarantee of BitSchema.

Output: Layout computation function with comprehensive test coverage including boundary cases and overflow detection.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/PROJECT.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/REQUIREMENTS.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-RESEARCH.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-01-PLAN.md
</context>

<feature>
  <name>Bit Layout Computation</name>
  <files>bitschema/layout.py, tests/test_layout.py</files>
  <behavior>
TDD for bit layout calculation covering requirements LAYOUT-01 through LAYOUT-05, TYPE-04.

**Test cases (RED phase):**

1. **Bit width calculation (TYPE-04)**
   - Boolean: 1 bit required
   - Integer [0, 1]: 1 bit (values 0..1)
   - Integer [0, 255]: 8 bits (values 0..255)
   - Integer [0, 256]: 9 bits (0..256 requires 9 bits)
   - Integer [-128, 127]: 8 bits (range size = 255)
   - Enum ["a", "b", "c"]: 2 bits (3 values, index 0..2)
   - Enum ["a"]: 0 bits (single value) - should handle edge case

2. **Sequential offset assignment (LAYOUT-01, LAYOUT-02)**
   - Schema: [boolean, integer[0,255]] → offsets [0, 1], bits [1, 8], total 9
   - Schema: [integer[0,15], boolean, integer[0,3]] → offsets [0, 4, 5], bits [4, 1, 2], total 7
   - Order must match input field order (LAYOUT-02)

3. **64-bit limit validation (LAYOUT-05)**
   - Schema with total 64 bits → succeeds
   - Schema with total 65 bits → raises SchemaError with breakdown
   - Schema: [8 integer[0,255] fields] → 64 bits exactly (boundary case)
   - Schema: [9 integer[0,255] fields] → 72 bits, raises SchemaError

4. **Determinism (LAYOUT-01)**
   - Same schema computed twice → identical offsets (validate determinism)

**Expected behavior:**
- `compute_bit_layout(fields)` returns `(layouts: list[FieldLayout], total_bits: int)`
- FieldLayout is NamedTuple with: name, type, offset, bits, constraints
- Use `int.bit_length()` for bit calculations (NOT math.log2)
- For signed integers: `(max - min).bit_length()`
- For enums: `(len(values) - 1).bit_length()`
- Raise SchemaError if total > 64, include per-field breakdown in message

  </behavior>
  <implementation>
**RED - Write failing tests:**

Create `tests/test_layout.py` with:
- Import pytest, bitschema.errors.SchemaError
- Create mock field objects (dicts or simple classes) for testing without full Pydantic models
- Test functions for each case above:
  - `test_bit_width_boolean`, `test_bit_width_integer_range`, `test_bit_width_signed_integer`
  - `test_sequential_offset_assignment`, `test_field_order_preserved`
  - `test_64_bit_limit_exact`, `test_64_bit_limit_exceeded`, `test_64_bit_limit_breakdown_message`
  - `test_layout_determinism`
- Use pytest.raises for error cases
- Run `pytest tests/test_layout.py` - ALL tests must fail (layout.py doesn't exist)
- Commit: `test(01-03): add failing tests for bit layout computation`

**GREEN - Implement to pass:**

Create `bitschema/layout.py`:
- Import: `from typing import NamedTuple; from .errors import SchemaError`
- Define `FieldLayout(NamedTuple)` with fields: name: str, type: str, offset: int, bits: int, constraints: dict
- Define `def compute_bit_layout(fields) -> tuple[list[FieldLayout], int]:`
  - Initialize offset = 0, layouts = []
  - For each field in fields (preserving order):
    - Compute bits based on field type:
      - Boolean: bits = 1
      - Integer: bits = (max_value - min_value).bit_length()
      - Enum: bits = (len(values) - 1).bit_length() if len(values) > 1 else 0
    - Create FieldLayout with current offset
    - Append to layouts
    - offset += bits
  - Validate offset <= 64, raise SchemaError with breakdown if exceeded
  - Return (layouts, offset)

Implementation notes from research:
- Use `int.bit_length()` NOT `math.log2()` (avoids float precision issues)
- For signed integers, compute range size: `max - min`
- Handle enum edge case: single-value enum needs 0 or 1 bit (decide based on tests)
- Error message format: "Schema exceeds 64-bit limit: 72 bits total. Breakdown: field1=8, field2=8, ..."

Run `pytest tests/test_layout.py` - ALL tests must pass
Commit: `feat(01-03): implement bit layout computation with 64-bit validation`

**REFACTOR (if needed):**
- Extract bit calculation logic into separate function: `compute_field_bits(field) -> int`
- Add comprehensive docstrings with examples
- Improve error message formatting
- Run tests - must still pass
- Commit if changes made: `refactor(01-03): extract bit calculation logic`

  </implementation>
</feature>

<verification>
After TDD cycle completion:

1. `pytest tests/test_layout.py -v` - All tests pass
2. Verify bit calculations: `python -c "from bitschema.layout import compute_bit_layout; print((255).bit_length())"` outputs 8
3. Test 64-bit overflow: Create schema with 65 bits, verify SchemaError raised with breakdown
4. Layout computation handles LAYOUT-01 through LAYOUT-05, TYPE-04
5. No dependency on Pydantic models yet (works with simple dicts/objects)
</verification>

<success_criteria>
- compute_bit_layout function exists and returns (layouts, total_bits)
- FieldLayout NamedTuple defined with name, type, offset, bits, constraints
- Bit width calculation uses int.bit_length() for all types (TYPE-04)
- Sequential offset assignment preserves field order (LAYOUT-01, LAYOUT-02)
- 64-bit limit validation with clear error breakdown (LAYOUT-05)
- Signed integer bit calculation correct: (max - min).bit_length()
- All tests in test_layout.py pass
- TDD cycle complete: RED → GREEN → (REFACTOR if needed)
- 2-3 commits created following TDD pattern
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
