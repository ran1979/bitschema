---
phase: 01-foundation
plan: 04
type: tdd
wave: 3
depends_on: ["01-02"]
files_modified:
  - bitschema/parser.py
  - tests/test_parser.py
  - tests/fixtures/valid_schema.json
  - tests/fixtures/valid_schema.yaml
  - tests/fixtures/invalid_schema.json
autonomous: true

must_haves:
  truths:
    - "Developer can load schema from JSON file into BitSchema model"
    - "Developer can load schema from YAML file into BitSchema model"
    - "System validates file format and rejects invalid JSON/YAML with clear errors"
  artifacts:
    - path: "bitschema/parser.py"
      provides: "Schema file parsing with JSON and YAML support"
      exports: ["parse_schema_file"]
      contains: "yaml.safe_load"
      min_lines: 30
    - path: "tests/test_parser.py"
      provides: "Parser tests with fixture files"
      contains: "test_.*yaml.*safe"
      min_lines: 40
    - path: "tests/fixtures/valid_schema.json"
      provides: "Valid JSON test fixture"
      contains: '"fields"'
    - path: "tests/fixtures/valid_schema.yaml"
      provides: "Valid YAML test fixture"
      contains: 'fields:'
  key_links:
    - from: "bitschema/parser.py"
      to: "yaml.safe_load"
      via: "secure YAML parsing"
      pattern: "yaml\\.safe_load"
    - from: "bitschema/parser.py"
      to: "BitSchema"
      via: "Pydantic model instantiation"
      pattern: "BitSchema\\(\\*\\*"
---

<objective>
Implement secure JSON/YAML schema file parsing with Pydantic validation.

Purpose: Enable developers to load schema definitions from JSON or YAML files, converting them into validated BitSchema models. Uses yaml.safe_load() for security and Pydantic for automatic validation.

Output: Parser function with comprehensive tests including valid/invalid schemas and both file formats.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/PROJECT.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/REQUIREMENTS.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-RESEARCH.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-01-PLAN.md
@/Users/rbrandes/Documents/private/private-projects/BitSchema/.planning/phases/01-foundation/01-02-PLAN.md
</context>

<feature>
  <name>Schema File Parsing</name>
  <files>bitschema/parser.py, tests/test_parser.py, tests/fixtures/*.{json,yaml}</files>
  <behavior>
TDD for schema file parsing covering requirements SCHEMA-01, SCHEMA-02, SCHEMA-03.

**Test cases (RED phase):**

1. **JSON parsing (SCHEMA-01)**
   - Valid JSON file with boolean + integer fields → BitSchema instance
   - Valid JSON file with enum field → BitSchema instance
   - Invalid JSON syntax → JSONDecodeError (clear error)
   - JSON file with invalid schema (missing type) → Pydantic ValidationError

2. **YAML parsing (SCHEMA-02)**
   - Valid YAML file with same structure as JSON → BitSchema instance
   - Valid YAML with YAML-specific syntax (multiline, anchors) → BitSchema instance
   - Invalid YAML syntax → yaml.YAMLError
   - YAML file with invalid schema → Pydantic ValidationError

3. **Security (research recommendation)**
   - Verify yaml.safe_load() is used (NOT yaml.load())
   - YAML with Python object tags (!!python/object) → rejected safely

4. **File handling**
   - Non-existent file → FileNotFoundError
   - Unsupported file extension (.txt) → ValueError with clear message
   - Empty file → ValidationError

5. **Pydantic integration (SCHEMA-03)**
   - Schema with duplicate field names → ValidationError from Pydantic
   - Schema with invalid field types → ValidationError from Pydantic
   - Pydantic errors preserve context (field name, constraint violated)

**Expected behavior:**
- `parse_schema_file(path: Path) -> BitSchema`
- Detects file type by extension: .json, .yaml, .yml
- Uses `json.load()` for JSON, `yaml.safe_load()` for YAML (SECURITY)
- Returns validated BitSchema model (Pydantic does validation)
- Raises appropriate errors with clear messages

**Test fixtures needed:**
- `tests/fixtures/valid_schema.json` - boolean, integer, enum fields
- `tests/fixtures/valid_schema.yaml` - same content, YAML format
- `tests/fixtures/invalid_syntax.json` - malformed JSON
- `tests/fixtures/invalid_schema.json` - valid JSON but invalid schema (duplicate names)
- `tests/fixtures/invalid_syntax.yaml` - malformed YAML

  </behavior>
  <implementation>
**RED - Write failing tests:**

Create `tests/fixtures/` directory and fixture files:
- `valid_schema.json`:
  ```json
  {
    "version": "1.0",
    "fields": [
      {"name": "active", "type": "boolean"},
      {"name": "age", "type": "integer", "min_value": 0, "max_value": 120},
      {"name": "status", "type": "enum", "values": ["new", "active", "archived"]}
    ]
  }
  ```
- `valid_schema.yaml`: Same content in YAML format
- `invalid_syntax.json`: `{"fields": [` (unclosed)
- `invalid_schema.json`: Valid JSON with duplicate field names
- `invalid_syntax.yaml`: `fields:\n  - name: test\n    type boolean` (missing colon)

Create `tests/test_parser.py`:
- Import pytest, Path, pydantic.ValidationError, json.JSONDecodeError, yaml.YAMLError
- Test functions for each case above:
  - `test_parse_valid_json`, `test_parse_valid_yaml`
  - `test_parse_invalid_json_syntax`, `test_parse_invalid_yaml_syntax`
  - `test_parse_invalid_schema`, `test_parse_duplicate_fields`
  - `test_parse_unsupported_extension`, `test_parse_nonexistent_file`
  - `test_yaml_uses_safe_load` (verify safe_load in implementation)
- Use pytest.raises for error cases
- Run `pytest tests/test_parser.py` - ALL tests must fail
- Commit: `test(01-04): add failing tests for schema file parsing`

**GREEN - Implement to pass:**

Create `bitschema/parser.py`:
- Import: `from pathlib import Path; import json; import yaml; from .schema import BitSchema`
- Define `def parse_schema_file(file_path: Path | str) -> BitSchema:`
  - Convert to Path if string
  - Check file exists, raise FileNotFoundError with path
  - Check extension in ['.json', '.yaml', '.yml'], raise ValueError for unsupported
  - Open file with encoding='utf-8'
  - If JSON: `data = json.load(f)` (may raise JSONDecodeError)
  - If YAML: `data = yaml.safe_load(f)` (CRITICAL: use safe_load NOT load)
  - Validate data is dict, raise ValueError if not
  - Return `BitSchema(**data)` (Pydantic validates, may raise ValidationError)

Implementation notes from research:
- ALWAYS use `yaml.safe_load()` to prevent code execution vulnerabilities
- Let exceptions propagate naturally (JSONDecodeError, YAMLError, ValidationError)
- Add docstring explaining security rationale for safe_load
- Handle both Path and str for convenience

Run `pytest tests/test_parser.py` - ALL tests must pass
Commit: `feat(01-04): implement secure schema file parser with JSON/YAML support`

**REFACTOR (if needed):**
- Add type hints for return value and parameters
- Improve error messages (wrap low-level errors with context)
- Add docstring with examples
- Extract file reading logic if complex
- Run tests - must still pass
- Commit if changes made: `refactor(01-04): improve parser error messages`

  </implementation>
</feature>

<verification>
After TDD cycle completion:

1. `pytest tests/test_parser.py -v` - All tests pass
2. Verify JSON parsing: `python -c "from bitschema.parser import parse_schema_file; from pathlib import Path; s = parse_schema_file(Path('tests/fixtures/valid_schema.json')); print(len(s.fields))"` outputs 3
3. Verify YAML parsing: `python -c "from bitschema.parser import parse_schema_file; from pathlib import Path; s = parse_schema_file(Path('tests/fixtures/valid_schema.yaml')); print(s.version)"` outputs "1.0"
4. Grep for yaml.load (NOT safe_load): `grep -n "yaml\.load" bitschema/parser.py` should only find "safe_load"
5. Parser handles SCHEMA-01, SCHEMA-02, delegates SCHEMA-03 to Pydantic
</verification>

<success_criteria>
- parse_schema_file function exists and accepts Path or str
- JSON files parsed using json.load() (SCHEMA-01)
- YAML files parsed using yaml.safe_load() (SCHEMA-02, security)
- Returns validated BitSchema instance (delegates to Pydantic for SCHEMA-03)
- Appropriate errors for invalid syntax, missing files, unsupported formats
- Test fixtures exist for both valid and invalid cases
- All tests in test_parser.py pass
- yaml.safe_load() is used (NOT yaml.load()) - verified by grep
- TDD cycle complete: RED → GREEN → (REFACTOR if needed)
- 2-3 commits created following TDD pattern
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
