---
phase: 04-testing-advanced-types
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_boundary_conditions.py
  - tests/test_roundtrip.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Test suite includes round-trip tests for all field types with boundary conditions"
    - "Property-based tests discover edge cases in bit-packing logic automatically"
    - "Tests verify nullable field combinations across all types"
  artifacts:
    - path: "tests/test_boundary_conditions.py"
      provides: "Systematic boundary condition testing with Hypothesis"
      min_lines: 200
    - path: "tests/test_roundtrip.py"
      provides: "Extended round-trip tests with increased example counts"
      contains: "@settings(max_examples="
    - path: "tests/conftest.py"
      provides: "Shared test fixtures and Hypothesis strategies"
      contains: "@st.composite"
  key_links:
    - from: "tests/test_boundary_conditions.py"
      to: "hypothesis.strategies"
      via: "import and use composite strategies"
      pattern: "from hypothesis import.*strategies"
    - from: "tests/test_roundtrip.py"
      to: "bitschema.encoder.encode"
      via: "round-trip verification"
      pattern: "decode\\(encode\\("
---

<objective>
Establish comprehensive test coverage using property-based testing to verify bit-packing correctness across all existing field types and edge cases.

Purpose: Fulfill TEST-01, TEST-02, TEST-03, TEST-05 requirements by extending existing Hypothesis integration with systematic boundary testing and increased coverage
Output: Test suite with 500+ property-based examples covering min/max boundaries, nullable combinations, and edge cases for all field types
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-advanced-types/04-RESEARCH.md
@tests/test_roundtrip.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Create systematic boundary condition test suite</name>
  <files>tests/test_boundary_conditions.py</files>
  <action>
Create `tests/test_boundary_conditions.py` with property-based tests for edge cases:

1. **Integer boundary tests:**
   - Min/max values for bounded integers
   - Negative ranges (-1000 to 1000)
   - Single-value ranges (min == max)
   - Maximum bit width (64-bit field)
   - Off-by-one errors at boundaries

2. **Enum boundary tests:**
   - Single-value enums (0 bits)
   - Two-value enums (1 bit)
   - Maximum enum size that fits in remaining bits
   - Enum index at exact max boundary

3. **Boolean edge cases:**
   - True/False values
   - Combined with other fields at bit boundaries

4. **Nullable field combinations:**
   - All None values
   - Mix of None and present values
   - Nullable at different bit offsets

Use Hypothesis `@given` with `@settings(max_examples=500)` for thorough coverage.
Follow existing test patterns from `tests/test_roundtrip.py`.
Organize into test classes by field type: `TestIntegerBoundaries`, `TestEnumBoundaries`, `TestNullableBoundaries`.
  </action>
  <verify>pytest tests/test_boundary_conditions.py -v</verify>
  <done>All boundary condition tests pass with 500+ examples per test, covering min/max edge cases for all field types</done>
</task>

<task type="auto">
  <name>Extend round-trip tests with increased example counts</name>
  <files>tests/test_roundtrip.py</files>
  <action>
Update existing `tests/test_roundtrip.py` to increase coverage:

1. **Increase max_examples to 500** for all existing property tests:
   - Add `@settings(max_examples=500)` decorator to all `@given` tests
   - Keep existing test logic unchanged

2. **Add multi-field edge case combinations:**
   - Test class `TestMultiFieldEdgeCases` with:
     - All fields at min values
     - All fields at max values
     - Alternating min/max across fields
     - Random valid combinations (existing behavior)

3. **Add nullable field stress tests:**
   - All fields nullable, all None
   - All fields nullable, all present
   - Random nullable patterns

Follow existing pattern: FieldLayout → encode → decode → assert equality.
Use Hypothesis strategies from existing tests.
  </action>
  <verify>pytest tests/test_roundtrip.py -v --hypothesis-show-statistics</verify>
  <done>Round-trip tests run with 500 examples each, Hypothesis statistics show increased coverage, all tests pass</done>
</task>

<task type="auto">
  <name>Add shared Hypothesis strategies to conftest</name>
  <files>tests/conftest.py</files>
  <action>
Extend `tests/conftest.py` with reusable Hypothesis strategies:

1. **Composite strategy for bounded integers:**
```python
@st.composite
def bounded_integer_field(draw, min_val=None, max_val=None):
    """Generate bounded integer field definition with valid constraints."""
    if min_val is None:
        min_val = draw(st.integers(min_value=-10000, max_value=10000))
    if max_val is None:
        max_val = draw(st.integers(min_value=min_val, max_value=min_val + 1000))
    return {
        "type": "integer",
        "min": min_val,
        "max": max_val,
        "nullable": draw(st.booleans())
    }
```

2. **Composite strategy for enum fields:**
```python
@st.composite
def enum_field(draw, num_values=None):
    """Generate enum field definition with valid values."""
    if num_values is None:
        num_values = draw(st.integers(min_value=1, max_value=20))
    values = [f"value_{i}" for i in range(num_values)]
    return {
        "type": "enum",
        "values": values,
        "nullable": draw(st.booleans())
    }
```

3. **Composite strategy for multi-field schemas:**
```python
@st.composite
def multi_field_schema(draw, num_fields=None):
    """Generate schema with multiple fields that fit in 64 bits."""
    # Implementation that ensures total bits <= 64
```

Make strategies importable by other test modules.
  </action>
  <verify>pytest tests/test_boundary_conditions.py tests/test_roundtrip.py -v</verify>
  <done>Shared strategies defined in conftest.py, imported and used by boundary and round-trip tests, all tests pass</done>
</task>

</tasks>

<verification>
Run full test suite with coverage:
```bash
pytest tests/ -v --hypothesis-show-statistics
pytest tests/test_boundary_conditions.py tests/test_roundtrip.py -v
```

Verify Hypothesis settings:
```bash
grep -r "@settings(max_examples=" tests/
```

Check test count:
```bash
pytest tests/test_boundary_conditions.py --collect-only
pytest tests/test_roundtrip.py --collect-only
```
</verification>

<success_criteria>
- [ ] `tests/test_boundary_conditions.py` exists with 10+ property-based tests
- [ ] All boundary tests use `@settings(max_examples=500)`
- [ ] Tests cover min/max boundaries for integers, enums, booleans, nullables
- [ ] `tests/test_roundtrip.py` updated with 500 examples per test
- [ ] Shared Hypothesis strategies defined in `tests/conftest.py`
- [ ] All tests pass with Hypothesis statistics showing increased coverage
- [ ] pytest --collect-only shows 30+ total property tests across both files
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-advanced-types/04-01-SUMMARY.md`
</output>
