---
phase: 04-testing-advanced-types
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - bitschema/models.py
  - bitschema/layout.py
  - bitschema/encoder.py
  - bitschema/decoder.py
  - tests/test_date_fields.py
autonomous: true

must_haves:
  truths:
    - "Developer can define date fields with configurable resolution (day, hour, minute, second)"
    - "Date fields validate min_date and max_date range constraints"
    - "Date values encode to minimal bits based on range and resolution"
    - "Date fields round-trip correctly (encode then decode returns original date)"
  artifacts:
    - path: "bitschema/models.py"
      provides: "DateFieldDefinition Pydantic model"
      contains: "class DateFieldDefinition"
      min_lines: 40
    - path: "bitschema/layout.py"
      provides: "Date field bit calculation in compute_bits_for_field"
      pattern: "elif field_type == \"date\""
    - path: "bitschema/encoder.py"
      provides: "Date encoding logic in normalize_value"
      pattern: "datetime.*timedelta"
    - path: "bitschema/decoder.py"
      provides: "Date decoding logic in denormalize_value"
      pattern: "min_date \\+ timedelta"
    - path: "tests/test_date_fields.py"
      provides: "TDD test suite for date field functionality"
      min_lines: 150
  key_links:
    - from: "tests/test_date_fields.py"
      to: "bitschema.encoder.encode"
      via: "date field encoding"
      pattern: "encode\\(.*date"
    - from: "bitschema/models.py"
      to: "datetime.fromisoformat"
      via: "ISO 8601 date parsing"
      pattern: "fromisoformat"
    - from: "bitschema/layout.py"
      to: "bitschema.models.DateFieldDefinition"
      via: "field type dispatch"
      pattern: "DateFieldDefinition"
---

<objective>
Implement date field support with configurable resolution and range constraints using TDD methodology.

Purpose: Fulfill TYPE-07 and TYPE-08 requirements by adding date fields that encode timestamps efficiently using offset-from-epoch pattern
Output: Working date field type with day/hour/minute/second resolution, validated range constraints, and round-trip correctness
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-advanced-types/04-RESEARCH.md
@bitschema/models.py
@bitschema/layout.py
@bitschema/encoder.py
@bitschema/decoder.py
</context>

<feature>
  <name>Date Field Type</name>
  <files>
    bitschema/models.py
    bitschema/layout.py
    bitschema/encoder.py
    bitschema/decoder.py
    tests/test_date_fields.py
  </files>
  <behavior>
Date fields store dates/times using offset from min_date at configurable resolution:

**Schema definition:**
```yaml
fields:
  - name: timestamp
    type: date
    resolution: day  # or hour, minute, second
    min_date: "2020-01-01"
    max_date: "2030-12-31"
    nullable: false
```

**Bit calculation:**
- resolution="day": bits = (max_date - min_date).days.bit_length()
- resolution="hour": bits = ((max_date - min_date).total_seconds() / 3600).bit_length()
- resolution="minute": bits = ((max_date - min_date).total_seconds() / 60).bit_length()
- resolution="second": bits = (max_date - min_date).total_seconds().bit_length()

**Encoding:**
- Input: Python datetime.date or datetime.datetime object (or ISO 8601 string)
- Process: offset = (date_value - min_date) in resolution units
- Output: integer offset

**Decoding:**
- Input: integer offset
- Process: date = min_date + timedelta(resolution_units=offset)
- Output: Python datetime.date or datetime.datetime object

**Validation:**
- min_date < max_date (at schema load)
- date value >= min_date and <= max_date (at encoding)
- resolution in ["day", "hour", "minute", "second"]
- nullable adds 1 bit for presence
  </behavior>
  <implementation>
**RED - Write failing tests:**

1. Create `tests/test_date_fields.py` with test cases:
   - `test_date_field_schema_validation()` - validates min_date < max_date, valid resolution
   - `test_date_field_bit_calculation()` - verifies bits = (range / resolution).bit_length()
   - `test_date_field_encoding()` - date → offset integer
   - `test_date_field_decoding()` - offset integer → date
   - `test_date_field_roundtrip()` - encode → decode returns original
   - `test_date_field_all_resolutions()` - day, hour, minute, second
   - `test_date_field_nullable()` - None values with presence bit
   - `test_date_field_boundary_dates()` - min_date and max_date edge cases

Run tests - they MUST fail.

**GREEN - Implement to pass:**

2. Add `DateFieldDefinition` to `bitschema/models.py`:
```python
class DateFieldDefinition(BaseModel):
    type: Literal["date"] = "date"
    resolution: Literal["day", "hour", "minute", "second"]
    min_date: str  # ISO 8601 format
    max_date: str
    nullable: bool = False
    description: str | None = None

    @field_validator("min_date", "max_date")
    @classmethod
    def validate_iso_date(cls, v: str) -> str:
        try:
            datetime.fromisoformat(v)
            return v
        except ValueError:
            raise ValueError(f"Invalid ISO 8601 date: {v}")

    @model_validator(mode="after")
    def validate_date_range(self) -> "DateFieldDefinition":
        min_dt = datetime.fromisoformat(self.min_date)
        max_dt = datetime.fromisoformat(self.max_date)
        if min_dt >= max_dt:
            raise ValueError("min_date must be before max_date")
        return self
```

Update `FieldDefinition` union to include `DateFieldDefinition`.

3. Add date bit calculation to `bitschema/layout.py`:
```python
def compute_bits_for_field(field: dict) -> int:
    # ... existing logic ...
    elif field_type == "date":
        min_dt = datetime.fromisoformat(field["min_date"])
        max_dt = datetime.fromisoformat(field["max_date"])
        resolution = field["resolution"]

        if resolution == "day":
            total_units = (max_dt - min_dt).days
        elif resolution == "hour":
            total_units = int((max_dt - min_dt).total_seconds() / 3600)
        elif resolution == "minute":
            total_units = int((max_dt - min_dt).total_seconds() / 60)
        elif resolution == "second":
            total_units = int((max_dt - min_dt).total_seconds())

        bits = (total_units - 1).bit_length() if total_units > 0 else 0
        return bits
```

4. Add date encoding to `bitschema/encoder.py`:
```python
def normalize_value(value, field_type: str, constraints: dict):
    # ... existing logic ...
    elif field_type == "date":
        min_date_str = constraints["min_date"]
        min_date = datetime.fromisoformat(min_date_str)
        resolution = constraints["resolution"]

        # Parse input value
        if isinstance(value, str):
            value = datetime.fromisoformat(value)

        # Calculate offset
        if resolution == "day":
            offset = (value - min_date).days
        elif resolution == "hour":
            offset = int((value - min_date).total_seconds() / 3600)
        elif resolution == "minute":
            offset = int((value - min_date).total_seconds() / 60)
        elif resolution == "second":
            offset = int((value - min_date).total_seconds())

        return offset
```

5. Add date decoding to `bitschema/decoder.py`:
```python
def denormalize_value(normalized, field_type: str, constraints: dict):
    # ... existing logic ...
    elif field_type == "date":
        min_date_str = constraints["min_date"]
        min_date = datetime.fromisoformat(min_date_str)
        resolution = constraints["resolution"]

        if resolution == "day":
            return (min_date + timedelta(days=normalized)).date()
        elif resolution == "hour":
            return min_date + timedelta(hours=normalized)
        elif resolution == "minute":
            return min_date + timedelta(minutes=normalized)
        elif resolution == "second":
            return min_date + timedelta(seconds=normalized)
```

Run tests - they MUST pass.

**REFACTOR (if needed):**

6. Extract common date parsing logic if duplication exists.
7. Add helper functions for resolution-to-timedelta conversion.
8. Improve error messages for invalid date values.

Run tests - MUST still pass.
  </implementation>
</feature>

<verification>
TDD cycle verification:

RED phase:
```bash
pytest tests/test_date_fields.py -v
# Should show failures
```

GREEN phase:
```bash
pytest tests/test_date_fields.py -v
# Should show all passing
```

Integration:
```bash
pytest tests/ -v
# All existing tests still pass
```
</verification>

<success_criteria>
- [ ] `tests/test_date_fields.py` created with 8+ test cases
- [ ] RED phase: tests fail initially
- [ ] `DateFieldDefinition` added to `bitschema/models.py` with validation
- [ ] Date bit calculation added to `bitschema/layout.py`
- [ ] Date encoding added to `bitschema/encoder.py`
- [ ] Date decoding added to `bitschema/decoder.py`
- [ ] GREEN phase: all date field tests pass
- [ ] All four resolutions (day, hour, minute, second) work correctly
- [ ] Round-trip tests verify encode(decode(x)) == x for dates
- [ ] Nullable date fields work with presence bits
- [ ] All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-advanced-types/04-02-SUMMARY.md`
</output>
