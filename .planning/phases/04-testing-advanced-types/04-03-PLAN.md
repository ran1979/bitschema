---
phase: 04-testing-advanced-types
plan: 03
type: tdd
wave: 2
depends_on: ["04-02"]
files_modified:
  - bitschema/models.py
  - bitschema/layout.py
  - bitschema/encoder.py
  - bitschema/decoder.py
  - tests/test_bitmask_fields.py
autonomous: true

must_haves:
  truths:
    - "Developer can define bitmask fields with multiple boolean flags"
    - "Bitmask fields validate unique flag positions within 0-63 range"
    - "Multiple flags can be set/unset using bitwise operations"
    - "Bitmask fields round-trip correctly (encode then decode preserves flag states)"
  artifacts:
    - path: "bitschema/models.py"
      provides: "BitmaskFieldDefinition Pydantic model"
      contains: "class BitmaskFieldDefinition"
      min_lines: 40
    - path: "bitschema/layout.py"
      provides: "Bitmask field bit calculation in compute_bits_for_field"
      pattern: "elif field_type == \"bitmask\""
    - path: "bitschema/encoder.py"
      provides: "Bitmask encoding logic in normalize_value"
      pattern: "field_type == \"bitmask\""
    - path: "bitschema/decoder.py"
      provides: "Bitmask decoding logic in denormalize_value"
      pattern: "field_type == \"bitmask\""
    - path: "tests/test_bitmask_fields.py"
      provides: "TDD test suite for bitmask field functionality"
      min_lines: 150
  key_links:
    - from: "tests/test_bitmask_fields.py"
      to: "bitschema.encoder.encode"
      via: "bitmask field encoding"
      pattern: "encode\\(.*flags"
    - from: "bitschema/models.py"
      to: "pydantic.field_validator"
      via: "flag position uniqueness validation"
      pattern: "@field_validator\\(\"flags\"\\)"
    - from: "bitschema/encoder.py"
      to: "bitwise OR operations"
      via: "flag combination"
      pattern: "\\|"
---

<objective>
Implement bitmask field support for compact storage of multiple boolean flags using TDD methodology.

Purpose: Fulfill TYPE-09 requirement by adding bitmask fields that store multiple on/off states efficiently
Output: Working bitmask field type with flag position validation, bitwise operations, and round-trip correctness
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-advanced-types/04-RESEARCH.md
@.planning/phases/04-testing-advanced-types/04-02-SUMMARY.md
@bitschema/models.py
@bitschema/layout.py
@bitschema/encoder.py
@bitschema/decoder.py
</context>

<feature>
  <name>Bitmask Field Type</name>
  <files>
    bitschema/models.py
    bitschema/layout.py
    bitschema/encoder.py
    bitschema/decoder.py
    tests/test_bitmask_fields.py
  </files>
  <behavior>
Bitmask fields store multiple boolean flags in a single integer using bit positions:

**Schema definition:**
```yaml
fields:
  - name: permissions
    type: bitmask
    flags:
      read: 0
      write: 1
      execute: 2
      delete: 3
    nullable: false
```

**Bit calculation:**
- bits = max(flag_positions) + 1
- Example: flags at positions [0, 1, 2, 3] requires 4 bits

**Encoding:**
- Input: dict of flag names to boolean values: {"read": True, "write": False, "execute": True}
- Process: Set bit at position for each True flag using bitwise OR
- Output: integer with bits set (e.g., 0b0101 = 5 for read=True, execute=True)

**Decoding:**
- Input: integer value
- Process: Check each bit position using bitwise AND
- Output: dict of flag names to boolean values

**Validation:**
- Flag positions must be unique (no two flags at same bit)
- Flag positions must be 0-63 (within 64-bit limit)
- At least one flag must be defined
- Flag names must be valid Python identifiers
  </behavior>
  <implementation>
**RED - Write failing tests:**

1. Create `tests/test_bitmask_fields.py` with test cases:
   - `test_bitmask_field_schema_validation()` - validates unique positions, 0-63 range, at least one flag
   - `test_bitmask_field_bit_calculation()` - bits = max(positions) + 1
   - `test_bitmask_field_encoding_single_flag()` - one flag set
   - `test_bitmask_field_encoding_multiple_flags()` - multiple flags set
   - `test_bitmask_field_encoding_no_flags()` - all flags False (value = 0)
   - `test_bitmask_field_decoding()` - integer → dict of flags
   - `test_bitmask_field_roundtrip()` - encode → decode returns original
   - `test_bitmask_field_nullable()` - None values with presence bit
   - `test_bitmask_field_all_combinations()` - property test with all flag combinations

Run tests - they MUST fail.

**GREEN - Implement to pass:**

2. Add `BitmaskFieldDefinition` to `bitschema/models.py`:
```python
class BitmaskFieldDefinition(BaseModel):
    type: Literal["bitmask"] = "bitmask"
    flags: dict[str, int]  # flag_name -> bit_position
    nullable: bool = False
    description: str | None = None

    @field_validator("flags")
    @classmethod
    def validate_flags(cls, v: dict[str, int]) -> dict[str, int]:
        if not v:
            raise ValueError("bitmask must have at least one flag")

        # Check unique positions
        positions = list(v.values())
        if len(set(positions)) != len(positions):
            raise ValueError("flag positions must be unique")

        # Check 0-63 range
        if any(pos < 0 or pos > 63 for pos in positions):
            raise ValueError("flag positions must be 0-63 for 64-bit limit")

        # Check valid Python identifiers
        for name in v.keys():
            if not name.isidentifier():
                raise ValueError(f"flag name '{name}' must be valid Python identifier")

        return v
```

Update `FieldDefinition` union to include `BitmaskFieldDefinition`.

3. Add bitmask bit calculation to `bitschema/layout.py`:
```python
def compute_bits_for_field(field: dict) -> int:
    # ... existing logic ...
    elif field_type == "bitmask":
        flags = field["flags"]
        if not flags:
            raise ValueError("bitmask must have at least one flag")
        max_position = max(flags.values())
        bits = max_position + 1
        return bits
```

4. Add bitmask encoding to `bitschema/encoder.py`:
```python
def normalize_value(value, field_type: str, constraints: dict):
    # ... existing logic ...
    elif field_type == "bitmask":
        flags_def = constraints["flags"]

        # value should be dict of flag_name -> bool
        if not isinstance(value, dict):
            raise ValueError(f"bitmask value must be dict, got {type(value)}")

        result = 0
        for flag_name, flag_position in flags_def.items():
            if value.get(flag_name, False):  # Default to False if not specified
                result |= (1 << flag_position)

        return result
```

5. Add bitmask decoding to `bitschema/decoder.py`:
```python
def denormalize_value(normalized, field_type: str, constraints: dict):
    # ... existing logic ...
    elif field_type == "bitmask":
        flags_def = constraints["flags"]

        result = {}
        for flag_name, flag_position in flags_def.items():
            result[flag_name] = bool(normalized & (1 << flag_position))

        return result
```

Run tests - they MUST pass.

**REFACTOR (if needed):**

6. Extract flag validation logic if duplicated.
7. Add helper functions for bitwise operations if clarity improves.
8. Improve error messages for invalid flag dictionaries.

Run tests - MUST still pass.
  </implementation>
</feature>

<verification>
TDD cycle verification:

RED phase:
```bash
pytest tests/test_bitmask_fields.py -v
# Should show failures
```

GREEN phase:
```bash
pytest tests/test_bitmask_fields.py -v
# Should show all passing
```

Integration:
```bash
pytest tests/ -v
# All existing tests still pass
```
</verification>

<success_criteria>
- [ ] `tests/test_bitmask_fields.py` created with 9+ test cases
- [ ] RED phase: tests fail initially
- [ ] `BitmaskFieldDefinition` added to `bitschema/models.py` with validators
- [ ] Flag position uniqueness validated at schema load
- [ ] Bitmask bit calculation added to `bitschema/layout.py`
- [ ] Bitmask encoding added to `bitschema/encoder.py`
- [ ] Bitmask decoding added to `bitschema/decoder.py`
- [ ] GREEN phase: all bitmask field tests pass
- [ ] Single flag, multiple flags, and no flags (all False) scenarios work
- [ ] Round-trip tests verify encode(decode(x)) == x for bitmasks
- [ ] Nullable bitmask fields work with presence bits
- [ ] All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-advanced-types/04-03-SUMMARY.md`
</output>
