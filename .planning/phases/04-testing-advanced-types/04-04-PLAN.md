---
phase: 04-testing-advanced-types
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - bitschema/codegen.py
  - bitschema/jsonschema.py
  - bitschema/visualization.py
  - tests/test_codegen_equivalence.py
autonomous: true

must_haves:
  truths:
    - "Generated dataclass code supports date and bitmask field types"
    - "Generated encode() produces identical results to runtime encoder for all field types"
    - "Generated decode() produces identical results to runtime decoder for all field types"
    - "JSON Schema export includes date and bitmask field definitions"
    - "Bit layout visualization displays date and bitmask fields correctly"
  artifacts:
    - path: "bitschema/codegen.py"
      provides: "Date and bitmask field code generation"
      pattern: "elif field_type == \"date\"|elif field_type == \"bitmask\""
      min_lines: 500
    - path: "bitschema/jsonschema.py"
      provides: "JSON Schema export for date and bitmask fields"
      pattern: "\"date\"|\"bitmask\""
    - path: "bitschema/visualization.py"
      provides: "Visualization for date and bitmask fields"
      pattern: "date|bitmask"
    - path: "tests/test_codegen_equivalence.py"
      provides: "Generated vs runtime equivalence tests"
      min_lines: 200
  key_links:
    - from: "tests/test_codegen_equivalence.py"
      to: "bitschema.codegen.generate_dataclass_code"
      via: "code generation"
      pattern: "generate_dataclass_code"
    - from: "tests/test_codegen_equivalence.py"
      to: "exec() for generated code"
      via: "dynamic code execution"
      pattern: "exec\\(code, namespace\\)"
    - from: "bitschema/codegen.py"
      to: "bitschema.encoder.normalize_value"
      via: "must match encoding logic"
      pattern: "normalize_value"
---

<objective>
Extend code generation, JSON Schema export, and visualization to support date and bitmask fields, with systematic testing to verify generated code matches runtime encoding.

Purpose: Complete TYPE-07, TYPE-08, TYPE-09 implementation and fulfill TEST-04 requirement for generated vs runtime equivalence
Output: Full support for date and bitmask fields across all BitSchema features with verified equivalence
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-testing-advanced-types/04-RESEARCH.md
@.planning/phases/04-testing-advanced-types/04-02-SUMMARY.md
@.planning/phases/04-testing-advanced-types/04-03-SUMMARY.md
@bitschema/codegen.py
@bitschema/jsonschema.py
@bitschema/visualization.py
@tests/test_codegen.py
</context>

<tasks>

<task type="auto">
  <name>Extend code generation for date and bitmask fields</name>
  <files>bitschema/codegen.py</files>
  <action>
Update `bitschema/codegen.py` to generate code for date and bitmask fields:

1. **Add date field type hints:**
   - Import `datetime` module in generated code
   - Field type: `datetime.date | None` for nullable, `datetime.date` otherwise
   - For non-day resolutions, use `datetime.datetime`

2. **Add date field encoding in generate_encode_method:**
```python
elif field_type == "date":
    min_date = datetime.fromisoformat("{constraints['min_date']}")
    resolution = "{constraints['resolution']}"

    if resolution == "day":
        offset = (self.{field_name} - min_date).days
    elif resolution == "hour":
        offset = int((self.{field_name} - min_date).total_seconds() / 3600)
    # ... etc
```

3. **Add date field decoding in generate_decode_method:**
```python
elif field_type == "date":
    min_date = datetime.fromisoformat("{constraints['min_date']}")
    resolution = "{constraints['resolution']}"

    if resolution == "day":
        {field_name} = (min_date + timedelta(days=offset)).date()
    # ... etc
```

4. **Add bitmask field type hints:**
   - Field type: `dict[str, bool] | None` for nullable, `dict[str, bool]` otherwise

5. **Add bitmask field encoding in generate_encode_method:**
```python
elif field_type == "bitmask":
    flags_def = {constraints['flags']}
    result = 0
    for flag_name, flag_position in flags_def.items():
        if self.{field_name}.get(flag_name, False):
            result |= (1 << flag_position)
    offset = result
```

6. **Add bitmask field decoding in generate_decode_method:**
```python
elif field_type == "bitmask":
    flags_def = {constraints['flags']}
    result = {{}}
    for flag_name, flag_position in flags_def.items():
        result[flag_name] = bool(offset & (1 << flag_position))
    {field_name} = result
```

Follow existing pattern from integer/enum/boolean fields.
Ensure generated code matches runtime encoder/decoder logic exactly.
Add `from datetime import datetime, timedelta` to imports when date fields present.
  </action>
  <verify>pytest tests/test_codegen.py -v -k "date or bitmask"</verify>
  <done>Generated dataclass code includes date and bitmask field support, matches runtime encoding/decoding logic</done>
</task>

<task type="auto">
  <name>Extend JSON Schema export for date and bitmask fields</name>
  <files>bitschema/jsonschema.py</files>
  <action>
Update `bitschema/jsonschema.py` to export date and bitmask fields:

1. **Add date field to JSON Schema conversion:**
```python
elif field_type == "date":
    field_schema = {
        "type": "string",
        "format": "date" if constraints.get("resolution") == "day" else "date-time",
        "x-bitschema-resolution": constraints.get("resolution"),
        "x-bitschema-min-date": constraints.get("min_date"),
        "x-bitschema-max-date": constraints.get("max_date"),
    }
```

2. **Add bitmask field to JSON Schema conversion:**
```python
elif field_type == "bitmask":
    flags = constraints.get("flags", {})
    field_schema = {
        "type": "object",
        "properties": {
            flag_name: {"type": "boolean"}
            for flag_name in flags.keys()
        },
        "additionalProperties": False,
        "x-bitschema-flag-positions": flags,
    }
```

Follow existing nullable pattern (type arrays ["type", "null"]).
Add custom `x-bitschema-*` metadata for roundtrip capability.
  </action>
  <verify>pytest tests/test_jsonschema.py -v -k "date or bitmask"</verify>
  <done>JSON Schema export includes date and bitmask field definitions with proper types and metadata</done>
</task>

<task type="auto">
  <name>Extend bit layout visualization for date and bitmask fields</name>
  <files>bitschema/visualization.py</files>
  <action>
Update `bitschema/visualization.py` to display date and bitmask fields:

1. **Add date field constraint display:**
```python
elif field_type == "date":
    min_date = constraints.get("min_date")
    max_date = constraints.get("max_date")
    resolution = constraints.get("resolution")
    constraint_str = f"{min_date}..{max_date} ({resolution})"
```

2. **Add bitmask field constraint display:**
```python
elif field_type == "bitmask":
    flags = constraints.get("flags", {})
    num_flags = len(flags)
    flag_names = ", ".join(flags.keys())
    constraint_str = f"{num_flags} flags: {flag_names}"
```

Follow existing pattern from `_format_constraint_display()`.
Keep constraint strings concise but informative.
  </action>
  <verify>pytest tests/test_visualization.py -v -k "date or bitmask"</verify>
  <done>Bit layout visualization displays date and bitmask fields with readable constraint information</done>
</task>

<task type="auto">
  <name>Create generated vs runtime equivalence test suite</name>
  <files>tests/test_codegen_equivalence.py</files>
  <action>
Create `tests/test_codegen_equivalence.py` with systematic equivalence tests:

1. **Test structure:**
   - For each field type (integer, boolean, enum, date, bitmask)
   - For nullable and non-nullable variants
   - Property-based tests with Hypothesis

2. **Equivalence test pattern:**
```python
@given(date_value=date_in_range(...))
def test_date_field_equivalence(self, date_value):
    """Generated code produces same encoding as runtime for date fields."""
    # Setup schema with date field
    schema = BitSchema(...)
    layouts, _ = compute_bit_layout([...])

    # Generate code
    code = generate_dataclass_code(schema, layouts)
    namespace = {}
    exec(code, namespace)
    GeneratedClass = namespace["SchemaName"]

    # Test data
    data = {"timestamp": date_value}

    # Compare runtime vs generated encoding
    runtime_encoded = encode(data, layouts)
    instance = GeneratedClass(timestamp=date_value)
    generated_encoded = instance.encode()

    assert generated_encoded == runtime_encoded

    # Compare runtime vs generated decoding
    runtime_decoded = decode(runtime_encoded, layouts)
    generated_decoded_obj = GeneratedClass.decode(generated_encoded)
    generated_decoded = {"timestamp": generated_decoded_obj.timestamp}

    assert generated_decoded == runtime_decoded
```

3. **Test cases:**
   - `test_date_field_day_resolution_equivalence()`
   - `test_date_field_hour_resolution_equivalence()`
   - `test_date_field_nullable_equivalence()`
   - `test_bitmask_field_single_flag_equivalence()`
   - `test_bitmask_field_multiple_flags_equivalence()`
   - `test_bitmask_field_nullable_equivalence()`
   - `test_mixed_field_types_equivalence()` - all types together

Use Hypothesis `@given` with custom strategies from conftest.py.
Run with 500+ examples per test to verify equivalence across input space.
  </action>
  <verify>pytest tests/test_codegen_equivalence.py -v --hypothesis-show-statistics</verify>
  <done>Equivalence test suite verifies generated code matches runtime encoding for all field types including date and bitmask</done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
pytest tests/ -v
```

Check equivalence specifically:
```bash
pytest tests/test_codegen_equivalence.py -v --hypothesis-show-statistics
```

Verify all field types covered:
```bash
pytest tests/test_codegen.py tests/test_jsonschema.py tests/test_visualization.py -v -k "date or bitmask"
```

Integration test with example schemas:
```bash
python -m bitschema generate examples/date_schema.yaml
python -m bitschema generate examples/bitmask_schema.yaml
```
</verification>

<success_criteria>
- [ ] `bitschema/codegen.py` generates code for date fields (all resolutions)
- [ ] `bitschema/codegen.py` generates code for bitmask fields
- [ ] Generated code imports datetime/timedelta when date fields present
- [ ] `bitschema/jsonschema.py` exports date fields with proper JSON Schema format
- [ ] `bitschema/jsonschema.py` exports bitmask fields with object/properties pattern
- [ ] `bitschema/visualization.py` displays date and bitmask fields
- [ ] `tests/test_codegen_equivalence.py` created with 7+ equivalence tests
- [ ] All equivalence tests use Hypothesis with 500+ examples
- [ ] Equivalence tests verify both encode and decode paths
- [ ] All tests pass, confirming generated code matches runtime
- [ ] No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing-advanced-types/04-04-SUMMARY.md`
</output>
