---
phase: 02-runtime-encoding
plan: 04
type: tdd
wave: 3
depends_on: [02-01]
files_modified:
  - bitschema/decoder.py
  - tests/test_decoder.py
autonomous: true

must_haves:
  truths:
    - "Decoder accepts 64-bit integer and layouts, returns dict"
    - "Decoder extracts bits using mask and shift at field offset"
    - "Decoder converts bit values to booleans (0→False, 1→True)"
    - "Decoder denormalizes integers (add min to extracted value)"
    - "Decoder converts enum indices to string values"
    - "Decoder decodes nullable fields checking presence bit"
  artifacts:
    - path: "bitschema/decoder.py"
      provides: "Decode function and bit extraction logic"
      exports: ["decode", "denormalize_value"]
      min_lines: 60
    - path: "tests/test_decoder.py"
      provides: "Decoder tests for all field types"
      min_lines: 80
  key_links:
    - from: "bitschema/decoder.py"
      to: "bitschema/layout.py"
      via: "Uses FieldLayout offset and bits for extraction"
      pattern: "layout\\.offset.*layout\\.bits"
---

<objective>
Implement bit-unpacking decoder that transforms 64-bit integer to Python dict.

Purpose: Implements DECODE-01, DECODE-02, DECODE-03, DECODE-04 requirements by extracting and denormalizing packed bits back to semantic values with nullable support.

Output: Decoder module with decode function, denormalization helpers, comprehensive tests for all field types including nullable.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-runtime-encoding/02-RESEARCH.md
@.planning/phases/02-runtime-encoding/02-01-SUMMARY.md

From research (Pattern 2: Bit-Unpacking Decoder):
- Extract using: (encoded >> offset) & mask
- Denormalize extracted value to semantic type
- Nullable: check presence bit, return None if 0

From 02-01:
- FieldLayout has nullable flag
- Layout includes offset and bits for each field
</context>

<feature>
  <name>Bit-unpacking decoder</name>
  <files>
    bitschema/decoder.py
    tests/test_decoder.py
  </files>
  <behavior>
    decode(encoded: int, layouts: list[FieldLayout]) -> dict:
    - Initializes empty result dict
    - For each layout in order:
      - If nullable: check presence bit at offset
      - If presence bit = 0: set field to None, skip value bits
      - If presence bit = 1 or non-nullable: extract value bits
      - Create bit mask for field width
      - Extract bits: (encoded >> offset) & mask
      - Denormalize to semantic value
      - Store in result dict with field name
    - Return result dict

    denormalize_value(extracted: int, layout: FieldLayout) -> Any:
    - bool: bool(extracted)
    - int: extracted + min (denormalize from unsigned)
    - enum: values[extracted] (index to string)

    Test cases:
    - Decode 1 with bool at offset=0 → {"active": True}
    - Decode 0 with bool at offset=0 → {"active": False}
    - Decode 42 with int(min=0,max=127) at offset=0 → {"age": 42}
    - Decode 5 with int(min=-10,max=10) at offset=0 → {"temp": -5}
    - Decode 1 with enum["idle","active","done"] at offset=0 → {"status": "active"}
    - Decode multiple fields at different offsets → correct dict
    - Decode nullable with presence=0 → {"field": None}
    - Decode nullable with presence=1 → {"field": value}
  </behavior>
  <implementation>
    1. Create bitschema/decoder.py with decode and denormalize_value functions
    2. decode loops over layouts in order
    3. Handle nullable fields: extract presence bit, return None if 0
    4. Extract bits using (encoded >> offset) & ((1 << bits) - 1)
    5. Implement denormalize_value for bool/int/enum types
    6. Track current offset for nullable fields (presence + value bits)
    7. Update bitschema/__init__.py to export decode
  </implementation>
</feature>

<verification>
Run tests:
```bash
cd /Users/rbrandes/Documents/private/private-projects/BitSchema
pytest tests/test_decoder.py -v
```

Verify:
- Boolean extraction works (0→False, 1→True)
- Integer denormalization correct (including negative ranges)
- Enum extraction converts index to value
- Nullable fields decode to None when presence=0
- Multiple fields extract from correct offsets
- No bit overlap or extraction errors
</verification>

<success_criteria>
- decode function accepts int and layouts, returns dict
- Boolean decoding works (0→False, 1→True)
- Integer decoding denormalizes correctly
- Enum decoding converts index to string
- Nullable decoding checks presence bit
- Multiple fields decode without corruption
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-runtime-encoding/02-04-SUMMARY.md` following the summary template with:
- TDD cycle commits (RED: failing tests, GREEN: implementation)
- Decoder module with bit extraction pattern
- Denormalization logic for all field types
- Nullable field presence bit checking
- Test coverage for single fields, multiple fields, nullable fields
</output>
