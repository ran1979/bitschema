---
phase: 02-runtime-encoding
plan: 03
type: tdd
wave: 3
depends_on: [02-02]
files_modified:
  - bitschema/encoder.py
  - tests/test_encoder.py
autonomous: true

must_haves:
  truths:
    - "Encoder accepts data dict and layouts, returns 64-bit integer"
    - "Encoder validates data before any bit operations"
    - "Encoder packs boolean as 0 or 1 at field offset"
    - "Encoder packs integers normalized to unsigned (value - min)"
    - "Encoder packs enums as index into values list"
    - "Encoder packs nullable fields with presence bit + value bits"
  artifacts:
    - path: "bitschema/encoder.py"
      provides: "Encode function and bit packing logic"
      exports: ["encode", "normalize_value"]
      min_lines: 80
    - path: "tests/test_encoder.py"
      provides: "Encoder tests for all field types"
      min_lines: 100
  key_links:
    - from: "bitschema/encoder.py"
      to: "bitschema/validator.py"
      via: "validate_data call before encoding"
      pattern: "validate_data\\(.*data.*layouts"
    - from: "bitschema/encoder.py"
      to: "bitschema/layout.py"
      via: "Uses FieldLayout offset and bits"
      pattern: "layout\\.offset.*layout\\.bits"
---

<objective>
Implement bit-packing encoder that transforms Python dict to 64-bit integer.

Purpose: Implements ENCODE-01, ENCODE-05, ENCODE-06 requirements by encoding validated data into packed integer using LSB-first accumulator pattern with nullable field support.

Output: Encoder module with encode function, normalization helpers, comprehensive tests for all field types including nullable.
</objective>

<execution_context>
@/Users/rbrandes/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rbrandes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-runtime-encoding/02-RESEARCH.md
@.planning/phases/02-runtime-encoding/02-01-SUMMARY.md
@.planning/phases/02-runtime-encoding/02-02-SUMMARY.md

From research (Pattern 1: Bit-Packing Encoder):
- LSB-first accumulator pattern (start at offset 0, work up)
- Normalize values to unsigned before packing
- Use bitwise OR to pack: accumulator |= ((normalized & mask) << offset)
- Nullable: presence bit at offset, value bits at offset+1

From 02-02:
- validate_data available for pre-encoding validation
- EncodingError for validation failures
</context>

<feature>
  <name>LSB-first bit-packing encoder</name>
  <files>
    bitschema/encoder.py
    tests/test_encoder.py
  </files>
  <behavior>
    encode(data: dict, layouts: list[FieldLayout]) -> int:
    - Validates data using validate_data (fails fast if invalid)
    - Initializes accumulator = 0
    - For each layout in order:
      - If nullable and value is None: skip bits (leave as 0)
      - If nullable and value is present: set presence bit, pack value
      - Normalize value to unsigned representation
      - Create bit mask for field width
      - Pack into accumulator using OR and left shift
    - Return accumulator as 64-bit integer

    normalize_value(value: Any, layout: FieldLayout) -> int:
    - bool: 1 if True else 0
    - int: value - min (normalize to unsigned)
    - enum: index in values list

    Test cases:
    - Single bool field: encode({"active": True}) with offset=0 → 1
    - Single bool field: encode({"active": False}) with offset=0 → 0
    - Single int field: encode({"age": 42}) with min=0, max=127, offset=0 → 42
    - Single int field: encode({"temp": -5}) with min=-10, max=10, offset=0 → 5
    - Single enum: encode({"status": "active"}) with values=["idle","active","done"] → 1
    - Multiple fields: bool at offset=0, int at offset=1 → correctly packed
    - Nullable field with None: presence bit = 0
    - Nullable field with value: presence bit = 1, value bits correct
    - Validation failure: raises EncodingError before any packing
  </behavior>
  <implementation>
    1. Create bitschema/encoder.py with encode and normalize_value functions
    2. encode calls validate_data first (import from validator)
    3. Implement LSB-first accumulator loop over layouts
    4. Handle nullable fields: check if None, set presence bit if value present
    5. Implement normalize_value for bool/int/enum types
    6. Create bit masks using (1 << bits) - 1
    7. Pack using accumulator |= ((normalized & mask) << offset)
    8. Update bitschema/__init__.py to export encode
  </implementation>
</feature>

<verification>
Run tests:
```bash
cd /Users/rbrandes/Documents/private/private-projects/BitSchema
pytest tests/test_encoder.py -v
```

Verify:
- Boolean fields encode to 0 or 1
- Integer fields normalize correctly (including negative ranges)
- Enum fields encode to index
- Nullable fields encode presence bit + value bits
- Multiple fields pack at correct offsets
- Validation runs before packing
</verification>

<success_criteria>
- encode function accepts dict and layouts, returns int
- Boolean encoding works (True→1, False→0)
- Integer encoding normalizes signed to unsigned
- Enum encoding converts to index
- Nullable encoding sets presence bit correctly
- Multiple fields pack without overlap
- Pre-encoding validation prevents invalid data
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-runtime-encoding/02-03-SUMMARY.md` following the summary template with:
- TDD cycle commits (RED: failing tests, GREEN: implementation)
- Encoder module with LSB-first accumulator pattern
- Normalization logic for all field types
- Nullable field presence bit handling
- Test coverage for single fields, multiple fields, nullable fields
</output>
