"""Tests verifying generated code matches runtime encoding/decoding exactly.

This test suite ensures that code generated by generate_dataclass_code()
produces identical results to the runtime encoder and decoder for all
field types including date and bitmask.

Uses property-based testing with Hypothesis to verify equivalence across
the entire input space with 500+ examples per test.
"""

import datetime
from datetime import date, timedelta
import pytest
from hypothesis import given, strategies as st, settings

from bitschema.models import (
    BitSchema,
    IntFieldDefinition,
    BoolFieldDefinition,
    EnumFieldDefinition,
    DateFieldDefinition,
    BitmaskFieldDefinition,
)
from bitschema.layout import compute_bit_layout
from bitschema.encoder import encode
from bitschema.decoder import decode
from bitschema.codegen import generate_dataclass_code


# Hypothesis strategies for generating test data


@st.composite
def date_in_range(draw, min_date_str, max_date_str):
    """Generate date within specified range."""
    min_date = datetime.datetime.fromisoformat(min_date_str)
    max_date = datetime.datetime.fromisoformat(max_date_str)
    days_diff = (max_date - min_date).days
    offset = draw(st.integers(min_value=0, max_value=days_diff))
    return (min_date + timedelta(days=offset)).date()


@st.composite
def datetime_in_range(draw, min_date_str, max_date_str, resolution):
    """Generate datetime within specified range and resolution."""
    min_dt = datetime.datetime.fromisoformat(min_date_str)
    max_dt = datetime.datetime.fromisoformat(max_date_str)

    if resolution == "hour":
        total_units = int((max_dt - min_dt).total_seconds() / 3600)
        offset = draw(st.integers(min_value=0, max_value=total_units))
        return min_dt + timedelta(hours=offset)
    elif resolution == "minute":
        total_units = int((max_dt - min_dt).total_seconds() / 60)
        offset = draw(st.integers(min_value=0, max_value=total_units))
        return min_dt + timedelta(minutes=offset)
    elif resolution == "second":
        total_units = int((max_dt - min_dt).total_seconds())
        offset = draw(st.integers(min_value=0, max_value=total_units))
        return min_dt + timedelta(seconds=offset)


@st.composite
def bitmask_value(draw, flags):
    """Generate bitmask value dict with random flag combinations."""
    return {
        flag_name: draw(st.booleans())
        for flag_name in flags.keys()
    }


class TestDateFieldEquivalence:
    """Test generated code matches runtime for date fields."""

    @settings(max_examples=500)
    @given(date_value=date_in_range("2020-01-01", "2020-12-31"))
    def test_date_field_day_resolution_equivalence(self, date_value):
        """Generated code produces same encoding as runtime for day resolution."""
        # Setup schema with date field
        schema = BitSchema(
            version="1",
            name="DateTest",
            fields={
                "event_date": DateFieldDefinition(
                    type="date",
                    resolution="day",
                    min_date="2020-01-01",
                    max_date="2020-12-31",
                    nullable=False,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        # Generate code
        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["DateTest"]

        # Test data
        data = {"event_date": date_value}

        # Compare runtime vs generated encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(event_date=date_value)
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded, (
            f"Encoding mismatch for {date_value}: "
            f"runtime={runtime_encoded}, generated={generated_encoded}"
        )

        # Compare runtime vs generated decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"event_date": generated_decoded_obj.event_date}

        assert generated_decoded == runtime_decoded, (
            f"Decoding mismatch: runtime={runtime_decoded}, generated={generated_decoded}"
        )

    @settings(max_examples=500)
    @given(datetime_value=datetime_in_range("2020-01-01T00:00:00", "2020-01-02T00:00:00", "hour"))
    def test_date_field_hour_resolution_equivalence(self, datetime_value):
        """Generated code produces same encoding as runtime for hour resolution."""
        schema = BitSchema(
            version="1",
            name="HourTest",
            fields={
                "timestamp": DateFieldDefinition(
                    type="date",
                    resolution="hour",
                    min_date="2020-01-01T00:00:00",
                    max_date="2020-01-02T00:00:00",
                    nullable=False,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["HourTest"]

        data = {"timestamp": datetime_value}

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(timestamp=datetime_value)
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"timestamp": generated_decoded_obj.timestamp}

        assert generated_decoded == runtime_decoded

    @settings(max_examples=500)
    @given(date_value=st.one_of(st.none(), date_in_range("2020-01-01", "2020-12-31")))
    def test_date_field_nullable_equivalence(self, date_value):
        """Generated code handles nullable date fields correctly."""
        schema = BitSchema(
            version="1",
            name="NullableDateTest",
            fields={
                "optional_date": DateFieldDefinition(
                    type="date",
                    resolution="day",
                    min_date="2020-01-01",
                    max_date="2020-12-31",
                    nullable=True,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["NullableDateTest"]

        data = {"optional_date": date_value}

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(optional_date=date_value)
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"optional_date": generated_decoded_obj.optional_date}

        assert generated_decoded == runtime_decoded


class TestBitmaskFieldEquivalence:
    """Test generated code matches runtime for bitmask fields."""

    @settings(max_examples=500)
    @given(flag_state=st.booleans())
    def test_bitmask_field_single_flag_equivalence(self, flag_state):
        """Generated code handles single flag bitmask correctly."""
        schema = BitSchema(
            version="1",
            name="SingleFlagTest",
            fields={
                "flags": BitmaskFieldDefinition(
                    type="bitmask",
                    flags={"enabled": 0},
                    nullable=False,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["SingleFlagTest"]

        data = {"flags": {"enabled": flag_state}}

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(flags={"enabled": flag_state})
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"flags": generated_decoded_obj.flags}

        assert generated_decoded == runtime_decoded

    @settings(max_examples=500)
    @given(flags_value=bitmask_value({"read": 0, "write": 1, "execute": 2, "admin": 5}))
    def test_bitmask_field_multiple_flags_equivalence(self, flags_value):
        """Generated code handles multiple flag bitmask correctly."""
        schema = BitSchema(
            version="1",
            name="PermissionsTest",
            fields={
                "permissions": BitmaskFieldDefinition(
                    type="bitmask",
                    flags={"read": 0, "write": 1, "execute": 2, "admin": 5},
                    nullable=False,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["PermissionsTest"]

        data = {"permissions": flags_value}

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(permissions=flags_value)
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"permissions": generated_decoded_obj.permissions}

        assert generated_decoded == runtime_decoded

    @settings(max_examples=500)
    @given(
        flags_value=st.one_of(
            st.none(),
            bitmask_value({"flag_a": 0, "flag_b": 1, "flag_c": 3})
        )
    )
    def test_bitmask_field_nullable_equivalence(self, flags_value):
        """Generated code handles nullable bitmask fields correctly."""
        schema = BitSchema(
            version="1",
            name="NullableFlagsTest",
            fields={
                "optional_flags": BitmaskFieldDefinition(
                    type="bitmask",
                    flags={"flag_a": 0, "flag_b": 1, "flag_c": 3},
                    nullable=True,
                )
            },
        )

        fields_list = [{"name": k, **v.model_dump()} for k, v in schema.fields.items()]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["NullableFlagsTest"]

        data = {"optional_flags": flags_value}

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(optional_flags=flags_value)
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {"optional_flags": generated_decoded_obj.optional_flags}

        assert generated_decoded == runtime_decoded


class TestMixedFieldTypesEquivalence:
    """Test generated code matches runtime for mixed field types."""

    @settings(max_examples=500)
    @given(
        active=st.booleans(),
        count=st.integers(min_value=0, max_value=255),
        status=st.sampled_from(["idle", "active", "done"]),
        event_date=date_in_range("2020-01-01", "2020-12-31"),
        flags=bitmask_value({"read": 0, "write": 1}),
    )
    def test_mixed_field_types_equivalence(self, active, count, status, event_date, flags):
        """Generated code handles all field types together correctly."""
        schema = BitSchema(
            version="1",
            name="MixedTest",
            fields={
                "active": BoolFieldDefinition(type="bool", nullable=False),
                "count": IntFieldDefinition(type="int", bits=8, min=0, max=255, nullable=False),
                "status": EnumFieldDefinition(type="enum", values=["idle", "active", "done"], nullable=False),
                "event_date": DateFieldDefinition(
                    type="date",
                    resolution="day",
                    min_date="2020-01-01",
                    max_date="2020-12-31",
                    nullable=False,
                ),
                "flags": BitmaskFieldDefinition(
                    type="bitmask",
                    flags={"read": 0, "write": 1},
                    nullable=False,
                ),
            },
        )

        # Convert Pydantic field types to layout field types
        fields_list = [
            {"name": "active", "type": "boolean"},
            {"name": "count", "type": "integer", "min": 0, "max": 255},
            {"name": "status", "type": "enum", "values": ["idle", "active", "done"]},
            {"name": "event_date", "type": "date", "resolution": "day", "min_date": "2020-01-01", "max_date": "2020-12-31"},
            {"name": "flags", "type": "bitmask", "flags": {"read": 0, "write": 1}},
        ]
        layouts, _ = compute_bit_layout(fields_list)

        code = generate_dataclass_code(schema, layouts)
        namespace = {}
        exec(code, namespace)
        GeneratedClass = namespace["MixedTest"]

        data = {
            "active": active,
            "count": count,
            "status": status,
            "event_date": event_date,
            "flags": flags,
        }

        # Compare encoding
        runtime_encoded = encode(data, layouts)
        instance = GeneratedClass(
            active=active,
            count=count,
            status=status,
            event_date=event_date,
            flags=flags,
        )
        generated_encoded = instance.encode()

        assert generated_encoded == runtime_encoded, (
            f"Encoding mismatch: runtime={runtime_encoded}, generated={generated_encoded}"
        )

        # Compare decoding
        runtime_decoded = decode(runtime_encoded, layouts)
        generated_decoded_obj = GeneratedClass.decode(generated_encoded)
        generated_decoded = {
            "active": generated_decoded_obj.active,
            "count": generated_decoded_obj.count,
            "status": generated_decoded_obj.status,
            "event_date": generated_decoded_obj.event_date,
            "flags": generated_decoded_obj.flags,
        }

        assert generated_decoded == runtime_decoded, (
            f"Decoding mismatch: runtime={runtime_decoded}, generated={generated_decoded}"
        )
